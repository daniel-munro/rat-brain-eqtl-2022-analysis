---
title: "Fuzzy eQTL overlap"
output: html_notebook
---

When determining eQTL overlap between tissues, consider the eSNPs. Either use an LD threshold to decide if the two eSNPs represent the same eQTL, or measure overlap quantitatively based on the LD. Use all conditionally independent eQTLs.

<!-- At least for the purpose of measuring overall overlap, I think I should use a quantitative measure. Otherwise, for a gene I could have two tissues matching and two/three other tissues matching independently, which would be difficult to show in aggregate. -->

I've previously measured LD in the subset individuals in each dataset, but when comparing across tissues the sets of individuals are slightly different. I'll just measure LD over all 88 individuals.

```{r}
suppressPackageStartupMessages(library(tidyverse))

load_geno <- function(chrom, start, end) {
    filename <- "../data/genotype/P50.rnaseq.88.unpruned.vcf.gz"
    rng <- GenomicRanges::GRanges(chrom, IRanges::IRanges(start, end))
    gt <- VariantAnnotation::readGT(filename, param = rng)
    geno <- apply(gt, 2, function(x) c("0|0" = 0, "0|1" = 1, "1|0" = 1, "1|1" = 2)[x])
    rownames(geno) <- rownames(gt)
    t(geno)
}

# .count <- 0
# LD_all_pairs <- function(geno, variant_id) {
#     .count <<- .count + 1
#     if (.count %% 1000 == 0) { print(.count) }
#     if (length(variant_id) == 1) {
#         return(tibble())
#     }
#     # geno <- load_geno(chrom[1], min(pos) - 1, max(pos) + 1)
#     ## If any IDs are the same, those pairs should still be included:
#     crossing(var1 = 1:length(variant_id),
#              var2 = 1:length(variant_id)) %>%
#         filter(var1 < var2) %>%
#         mutate(variant_id.x = variant_id[var1],
#                variant_id.y = variant_id[var2]) %>%
#         select(-var1, -var2) %>%
#         rowwise() %>%
#         mutate(LD = cor(geno[, variant_id.x], geno[, variant_id.y]) ^ 2) %>%
#         ungroup()
# }

.count <- 0
LD_clusters <- function(geno, variant_id, cutoffs) {
    .count <<- .count + 1
    if (.count %% 1000 == 0) { print(.count) }
    if (length(variant_id) == 1) {
        return(tibble(cutoff = cutoffs,
                      variant = 1L,
                      variant_id = variant_id,
                      cluster = 1L))
    }
    corr <- cor(geno[, variant_id, drop = FALSE])
    dis <- as.dist(1 - corr ^ 2)
    # Use WPGMA, which isn't affected by duplicate SNPs:
    hcl <- hclust(dis, method = "mcquitty")
    tibble(cutoff = cutoffs) %>%
        group_by(cutoff) %>%
        summarise(
            tibble(variant = 1:length(variant_id),
                   variant_id = variant_id,
                   cluster = cutree(hcl, h = 1 - cutoff)),
            .groups = "drop"
        )
}

eqtls <- read_tsv("../data/eqtls_indep.txt", col_types = "cccii----")

# # Get samples to subset genotypes when calculating LD:
# samples <- tibble(tissue = c("Acbc", "IL", "LHB", "PL", "VoLo")) %>%
#     group_by(tissue) %>%
#     summarise(
#         library = read.csv(str_glue("~/Dropbox (Scripps Research)/HS-RNASeq/quantitation/EnsemblGene_v2/log2+1/ensembl-gene_log2_{tissue}.txt"),
#                           sep = "\t", check.names = FALSE, nrows = 1) %>%
#             colnames(),
#         .groups = "drop"
#     ) %>%
#     separate(library, c("sample", "tissue2"))
```

```{r}
geno <- eqtls %>%
    distinct(chrom, pos) %>%
    # slice(1:100) %>%
    with(load_geno(chrom, pos, pos))

ld_cutoffs <- eqtls %>%
    # filter(gene_id == "ENSRNOG00000000040") %>%
    # slice(1:1000) %>%
    group_by(gene_id) %>%
    # summarise(LD_all_pairs(geno, variant_id),
    #           .groups = "drop")
    summarise(LD_clusters(geno, variant_id, cutoffs = seq(0, 1, length.out = 11)),
              .groups = "drop")

ld <- ld_cutoffs %>%
    filter(cutoff == 0.5) %>%
    select(-cutoff)
```

```{r}
# ld %>%
#     ggplot(aes(x = LD)) +
#     geom_histogram(bins = 50) +
#     ggtitle("LD between eSNPs of same-eGene eQTLs in different tissues")
```

<!-- Averaging those values per eGene: -->

```{r}
# ld2 <- ld %>%
#     group_by(gene_id) %>%
#     summarise(mean_LD = mean(LD), .groups = "drop")
# 
# ld2 %>%
#     ggplot(aes(x = mean_LD)) +
#     geom_histogram(bins = 50) +
#     ggtitle("mean LD between eSNPs per eGene")
```

I'm clustering all conditionally independent eQTLs per gene using LD as similarity measure and average linkage clustering (specifically WPGMA) followed by extracting clusters at different LD thresholds.

This heatmap shows how many clusters of eSNPs there are for each eGene, though it doesn't indicate how many eQTLs each eGene has.

```{r}
ld_cutoffs %>%
    group_by(gene_id, cutoff) %>%
    summarise(n_clusters = n_distinct(cluster),
              .groups = "drop") %>%
    ggplot(aes(x = gene_id, y = cutoff, fill = n_clusters)) +
    geom_tile() +
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank()) +
    xlab("eGene") +
    ylab("LD cutoff")
```

Faceting by number of eQTLs per gene:

```{r}
ld_cutoffs %>%
    group_by(gene_id, cutoff) %>%
    summarise(n_eqtls = n(),
              n_clusters = n_distinct(cluster),
              .groups = "drop") %>%
    ggplot(aes(x = gene_id, y = cutoff, fill = n_clusters)) +
    geom_tile() +
    facet_wrap(~n_eqtls, scales = "free_x") +
    theme(axis.text.x = element_blank()) +
    xlab("eGene") +
    ylab("LD cutoff")
```

Choosing LD cutoff 0.5 arbitrarily, and numbering clusters within each eGene arbitrarily, here is the number of eQTLs per eGene (either different tissues or independent in the same tissue) and how many clusters they are split into per gene:

```{r}
ld %>%
    group_by(gene_id) %>%
    mutate(count = n(),
           total = sum(cluster)) %>%
    ungroup() %>%
    arrange(desc(count), desc(total)) %>%
    mutate(cluster = as.factor(cluster),
           gene_id = as.integer(fct_inorder(gene_id))) %>%
    ggplot(aes(x = gene_id, fill = cluster)) +
    geom_bar() +
    # theme(axis.text.x = element_blank(),
    #       axis.ticks.x = element_blank()) +
    xlab("eGene") +
    ylab("No. total eQTLs across tissues")
```

